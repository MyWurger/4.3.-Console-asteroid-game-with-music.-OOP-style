#pragma once
/***************************************************************************
 *      Л А Б О Р А Т О Р Н А Я   Р А Б О Т А   № 2   П О   Т Р П О        *
 *-------------------------------------------------------------------------*
 *                                                                         *
 * Project Name  : Fly_Plate                                               *
 * Project Type  : Win64 Console application                               *
 * File Name     : Asteroid_co.h                                           *
 * Language      : VS2022                         C++                      *
 * Programmers   : Викулов Д. Г.                                           *
 * Modified By   :                                                         *
 * Created       : 01 / 11 / 2023                                          *
 * Last Revision : 16 / 11 / 2023                                          *
 * Comment(s)    : Игровое взаимодействие фигур через динамический         *
 *                 полиморфизм. Наследование Матрица переходов.            *
 *                 Абстрактные классы. Интерфейсы.                         *
 **************************************************************************/
#include "constants.h"
extern HDC hdc;


/*------------------------------------------------------------------------*/
/*                 Location               */
/*----------------------------------------*/

// базовый класс МЕСТОПОЛОЖЕНИЕ
class Location
{
protected:
	double m_X;                             // координата X
	double m_Y;                             // координата Y
public:
	Location(double InitX, double InitY);   // конструктор
	~Location();                            // деструктор
	double GetX() const;                    // константный геттер для получения X
	double GetY() const;                    // константный геттер для получения Y
	void SetX(double NewX);                 // сеттер для получения X
	void SetY(double NewY);                 // сеттер для получения Y
};// Location


/*------------------------------------------------------------------------*/
/*                Point                   */
/*----------------------------------------*/

// производный класс ТОЧКА от Location
class Point : public Location
{
protected:
	bool m_Visible;                         // светимость точки
public:
	Point(double InitX, double InitY);      // конструктор
	~Point();                               // деструктор
	bool IsVisible() const;                 // узнать про светимость точки
	void SetVisible(bool NewVisible);       // принудительно установить светимость точки
	void MoveTo(double NewX, double NewY);  // движение фигуры
	virtual void Show();                    // показать точку на экране
	virtual void Hide();                    // скрыть точку с экрана
};// Point




/*---------------------------------------------------------------------------------------------------------------------*/
/*            Астероиды           */
/*--------------------------------*/

/*------------------------------------------------------------------------*/
/*               Interface                */
/*----------------------------------------*/

// общие действия для всей иерархии астероидов, но разная реализация. Где-то используются, а где-то - нет
// функции интерфейса должны быть принудительно реализованы
class IAsteroid
{
	virtual void Body(HPEN Pen) = 0;                    // отрисовка контуров астероида
	virtual void Craters(HPEN Pen) = 0;                 // отрисовка кратеров астероида
	virtual void Galo(HPEN Pen, HBRUSH Brush) = 0;      // отрисовка закрашенного круга внутри Body
	virtual void Bumps(HPEN Pen) = 0;                   // отрисовка полосок
	virtual void Core(HPEN Pen, HBRUSH Brush) = 0;      // отрисовка ядра
	virtual void Stripes(HPEN Pen, HBRUSH Brush) = 0;   // отрисовка полосок
	virtual void Nimbus(HPEN Pen, HBRUSH Brush) = 0;    // отрисовка нимба
	virtual void Rays(HPEN Pen) = 0;                    // отрисовка лучей
};// IAsteroid


/*------------------------------------------------------------------------*/
/*                Asteroid                */
/*----------------------------------------*/

// производный класс АСТЕРОИД от интерфейса IAsteroid, от Point и по определению от Location
// фунции интерфейса должны быть принудительно реализованы
// тогда неиспользующиеся функции в этом классе будут иметь пустое тело
class Asteroid : public Point, public IAsteroid
{
protected:
	double m_size;                          // параметр для отрисовки и регулировки размера
	int m_number;                           // личный номер астероида
public:
	Asteroid(double InitX, double InitY);   // конструктор астероида
	~Asteroid();                            // деструктор
	double GetSize() const;                 // геттер для получения значения размера
	void SetSize(double NewSize);           // сеттер для принудительной установки значения размера
	int GetNumber() const;                  // геттер для получения значения номера
	void SetNumber(int NewNumber);          // сеттер для принудительной установки значения номера

	// виртуальные функции для динамического полиморфизма
	// реализация интерфейса
	void Body(HPEN Pen);                    // отрисовка контуров астероида
	void Craters(HPEN Pen);                 // отрисовка кратеров астероида
	void Galo(HPEN Pen, HBRUSH Brush) {}    // отрисовка закрашенного круга внутри Body. Здесь не нужна
	void Bumps(HPEN Pen) {}                 // отрисовка полосок. Здесь не нужна
	void Core(HPEN Pen, HBRUSH Brush) {}    // отрисовка ядра. Здесь не нужна
	void Stripes(HPEN Pen, HBRUSH Brush) {} // отрисовка полосок. Здесь не нужна
	void Nimbus(HPEN Pen, HBRUSH Brush) {}  // отрисовка нимба. Здесь не нужна
	void Rays(HPEN Pen) {}                  // отрисовка лучей. Здесь не нужна

	// виртуальные функции
	// умение показаться и скрыться с экрана есть. Реализация неизвестна
	void Show();                            // показать астероид на экране. Виртуальный метод
	void Hide();                            // скрыть астероид с экрана. Виртуальный метод

	virtual double Left_Border();           // вернуть значение самой левой точки астероида/ белого карлика/ белого остывшего карлика/ коричневого карлика
	virtual double Right_Border();          // вернуть значение самой правой точки астероида/ белого карлика/ белого остывшего карлика/ коричневого карлика
	virtual double High_Border();           // вернуть значение самой высокой точки астероида/ белого карлика/ белого остывшего карлика/ коричневого карлика
	virtual double Low_Border();            // вернуть значение самой низкой точки астероида/ белого карлика/ белого остывшего карлика/ коричневого карлика
};// Asteroid


// для следующей группы астероидов функции возврата точек границ одинаковы
/*------------------------------------------------------------------------*/
/*              White_Warlic              */
/*----------------------------------------*/

// производный класс БЕЛЫЙ КАРЛИК от Asteroid и по определению от Point и Location. И IAsteroid
class White_Warlic : public Asteroid
{
	// размер. Параметр для отрисовки объекта используется родителький. Меняется в конструкторе
	// номер меняется в конструкторе
public:
	White_Warlic(double InitX, double InitY);          // конструктор
	~White_Warlic();                                   // деструктор

	// виртуальные функции из интерфейса
	void Galo(HPEN Pen, HBRUSH Brush);                 // отрисовка закрашенного круга внутри Body
	// методы получения границ заимствуются из класса Asteroid

	// виртуальные функции
	void Show();                                       // показать Белого карлика на экране. Виртуальный метод
	void Hide();                                       // скрыть Белого карлика с экрана. Виртуальный метод
};// White_Warlic


/*------------------------------------------------------------------------*/
/*            Cold_White_Warlic           */
/*----------------------------------------*/

// производный класс ОСТЫВШИЙ БЕЛЫЙ КАРЛИК от Белого карлика и по определению от Asteroid, Point и Location. И IAsteroid. Вертикальное наследование
class Cold_White_Warlic : public White_Warlic
{
	// размер. Параметр для отрисовки объекта. Меняется в конструкторе
	// номер меняется в конструкторе
public:
	Cold_White_Warlic(double InitX, double InitY);     // конструктор
	~Cold_White_Warlic();                              // деструктор

	// виртуальные функции из интерфейса
	void Bumps(HPEN Pen);                              // отрисовка полосок
	void Core(HPEN Pen, HBRUSH Brush);                 // отрисовка ядра

	// виртуальные функции
	void Show();                                       // показать остывшего белого карлика на экране. Виртуальный метод
	void Hide();                                       // скрыть остывшего белого карлика с экрана. Виртуальный метод
};// Cold_White_Warlic


/*------------------------------------------------------------------------*/
/*            Brown_Warlic           */
/*-----------------------------------*/

// производный класс Коричневый карлик от Asteroid и по отпределению от Point и Location. И IAsteroid.
class Brown_Warlic : public Asteroid
{
	// размер. Параметр для отрисовки объекта. Меняется в конструкторе
	// номер меняется в конструкторе
public:
	Brown_Warlic(double InitX, double InitY);    // конструктор
	~Brown_Warlic();                             // деструктор

	// виртуальные функции из интерфейса
	void Stripes(HPEN Pen, HBRUSH Brush);        // отрисовка полосок

	// виртуальные функции
	void Show();                                 // показать коричневого карлика на экране. Виртуальный метод
	void Hide();                                 // скрыть коричневого карлика с экрана. Виртуальный метод
};// Brown_Warlic


// для этой группы астероидов границы уже будут другими
/*------------------------------------------------------------------------*/
/*            Neutron_Star           */
/*-----------------------------------*/

// производный класс Нейтронная звезда от Asteroid и по отпределению от Point и Location. И IAsteroid.
class Neutron_Star : public Asteroid
{
	// размер. Параметр для отрисовки объекта. Меняется в конструкторе
	// номер меняется в конструкторе
public:
	Neutron_Star(double InitX, double InitY);       // конструктор
	~Neutron_Star();                                // деструктор

	// виртуальные функции из интерфейса
	void Nimbus(HPEN Pen, HBRUSH Brush);            // отрисовка нимба
	void Rays(HPEN Pen);                            // отрисовка лучей

	// виртуальные функции
	void Show();                                    // показать нейтронную звезду на экране. Виртуальный метод
	void Hide();                                    // скрыть нейтронную звезду с экрана. Виртуальный метод

	// виртуальные функции
	double Left_Border();                           // вернуть значение самой левой точки нейтронной звезды   / мёртвой звезды. Виртуальный метод
	double Right_Border();                          // вернуть значение самой правой точки нейтронной звезды  / мёртвой звезды. Виртуальный метод
	double High_Border();                           // вернуть значение самой верхней точки нейтронной звезды / мёртвой звезды. Виртуальный метод
	double Low_Border();                            // вернуть значение самой нижней точки нейтронной звезды  / мёртвой звезды. Виртуальный метод
};// Neutron_Star


/*------------------------------------------------------------------------*/
/*            Dead_Star           */
/*--------------------------------*/

// производный класс Мертвая звезда от Neutron_Star  и по отпределению от Asteroid, Point и Location. И IAsteroid.
class Dead_Star : public Neutron_Star
{
	// размер. Параметр для отрисовки объекта. Меняется в конструкторе
	// номер меняется в конструкторе
public:
	Dead_Star(double InitX, double InitY);          // конструктор
	~Dead_Star();                                   // деструктор

	// виртуальные функции из интерфейса
	void Core(HPEN Pen, HBRUSH Brush);              // отрисовка контуров ядра
	void Bumps(HPEN Pen);                           // отрисовка полосок

	// виртуальные функции
	void Show();                                    // показать мертвую звезду на экране. Виртуальный метод
	void Hide();                                    // скрыть мертвую звезду с экрана. Виртуальный метод
};// Dead_Star




/*------------------------------------------------------------------------------------------------------*/
/*            Летающие тарелки         */
/*-------------------------------------*/

/*------------------------------------------------------------------------*/
/*               Interface                */
/*----------------------------------------*/

// общие действия для всей иерархии летающих тарелок, но разная реализация. Где-то используются, а где-то - нет
// фунции интерфейса должны быть принудительно реализованы
class IFlyingPlate
{
	virtual void Skirt(HPEN Pen) = 0;                    // отрисовка нижней "юбки корабля"
	virtual void Glass(HPEN Pen) = 0;                    // отрисовка стекла летающей тарелки
	virtual void Windows(HPEN Pen, HBRUSH Brush) = 0;    // отрисовка окон внутри тела летающей тарелки
	virtual void Legs(HPEN Pen) = 0;                     // отрисовка ножек/нижнего окна летающей тарелки
	virtual void Back(HPEN Pen) = 0;                     // отрисовка выпуклости посередине летающей тарелки            
};// IFlyingPlate


/*------------------------------------------------------------------------------------------------------*/
/*           FlyingPlate         */
/*-------------------------------*/

// производный класс ЛЕТАЮЩАЯ_ТАРЕЛКА от интерфейса IFlyingPlate, от Point и по определению от Location
// фунции интерфейса должны быть принудительно реализованы
// тогда неиспользующиеся функции в этом классе будут иметь пустое тело
class FlyingPlate : public Point, public IFlyingPlate
{
protected:
	double m_parametr;                                    // параметр для отрисовки и регулировки размера
	int m_num_plate;                                      // личный номер летающей тарелки
public:
	FlyingPlate(int InitX, int InitY);                    // конструктор летающей тарелки
	~FlyingPlate();                                       // деструктор
	double GetParametr() const;                           // константный геттер для получения значения размера
	void SetParameter(int NewParametr);                   // сеттер для принудительной установки значения размера
	int GetNum() const;                                   // константный геттер для получения значения номера
	void SetNum(int NewNum);                              // сеттер для принудительной установки значения личного номера

	// виртуальные функции для динамического полиморфизма
	//реализация интерфейса
	void Skirt(HPEN Pen);                                 // отрисовка нижней "юбки корабля"
	void Glass(HPEN Pen);                                 // отрисовка стекла летающей тарелки
	void Windows(HPEN Pen, HBRUSH Brush);                 // отрисовка окон внутри тела летающей тарелки
	void Legs(HPEN Pen);                                  // отрисовка ножек/нижнего окна летающей тарелки
	void Back(HPEN Pen) {};                               // отрисовка выпуклости посередине летающей тарелки. Здесь не нужна
	// виртуальные функции
	void Show();                                          // показать летающую тарелку на экране. Виртуальный метод
	void Hide();                                          // скрыть летающую тарелку с экрана. Виртуальный метод
	virtual int Left_Border();                            // вернуть значение самой левой точки летающей тарелки/   сломаной летающей тарелки
	virtual int Right_Border();                           // вернуть значение самой правой точки летающей тарелки/  сломаной летающей тарелки
	virtual int Low_Border();                             // вернуть значение самой низкой точки летающей тарелки/  сломаной летающей тарелки
	virtual int High_Border();                            // вернуть значение самой высокой точки летающей тарелки/ сломаной летающей тарелки
};// FlyingPlate


/*------------------------------------------------------------------------------------------------------*/
/*         Broke_FlyingPlate           */
/*-------------------------------------*/

// производный класс Сломаная Летающая_Тарелка от FlyingPlate и по определению от Point и Location. И IFlyingPlate
class Broke_FlyingPlate : public FlyingPlate
{
protected:
	// Размер. Параметр для отрисовки объекта. Используется поле родителя. Меняется в конструкторе
	// Жизнь. Параметр-флаг. Используется поле родителя. Меняется в конструкторе
public:
	Broke_FlyingPlate(int InitX, int InitY);     // конструктор
	~Broke_FlyingPlate();                        // деструктор
	void Glass(HPEN Pen);                        // отрисовка сломанного стекла сломанной летающей тарелки
	void Show();                                 // показать сломанную летающую тарелку на экране. Виртуальный метод
	void Hide();                                 // скрыть сломанную летающую тарелку с экрана. Виртуальный метод
};// Broke_FlyingPlate


/*------------------------------------------------------------------------------------------------------*/
/*        Angry_FlyingPlate           */
/*------------------------------------*/

// производный класс Злая Летающая_Тарелка от FlyingPlate и по определению от Point и Location. И IFlyingPlate
class Angry_FlyingPlate : public FlyingPlate
{
protected:
	// Размер. Параметр для отрисовки объекта. Используется поле родителя. Меняется в конструкторе
	// Жизнь. Параметр-флаг. Используется поле родителя. Меняется в конструкторе
public:
	Angry_FlyingPlate(int InitX, int InitY);         // конструктор
	~Angry_FlyingPlate();                            // деструктор
	void Skirt(HPEN Pen);                            // отрисовка нижней "юбки корабля" злой летающей тарелки
	void Glass(HPEN Pen);                            // отрисовка стекла злой летающей тарелки
	void Windows(HPEN Pen, HBRUSH Brush);            // отрисовка окон внутри тела злой летающей тарелки
	void Legs(HPEN Pen);                             // отрисовка ножек/нижнего окна злой летающей тарелки
	void Show();                                     // показать злую летающую тарелку на экране. Виртуальный метод
	void Hide();                                     // скрыть злую летающую тарелку с экрана. Виртуальный метод

	int Left_Border();                               // вернуть значение самой левой точки злой летающей тарелки
	int Right_Border();                              // вернуть значение самой правой точки злой летающей тарелки
	int Low_Border();                                // вернуть значение самой низкой точки злой летающей тарелки
	int High_Border();                               // вернуть значение самой левой точки злой летающей тарелки
};// Angry_FlyingPlate


/*------------------------------------------------------------------------------------------------------*/
/*             Modify_FlyingPlate             */
/*--------------------------------------------*/

// производный класс Модифицированная Летающая_Тарелка от Angry_FlyingPlate и по определению от FlyingPlate и Point и Location. И IFlyingPlate
class Modify_FlyingPlate : public Angry_FlyingPlate
{
protected:
	// Размер. Параметр для отрисовки объекта. Используется поле прародителя. Меняется в конструкторе
	// Жизнь. Параметр-флаг. Используется поле прародителя. Меняется в конструкторе
public:
	Modify_FlyingPlate(int InitX, int InitY);        // конструктор
	~Modify_FlyingPlate();                           // деструктор
	void Skirt(HPEN Pen);                            // отрисовка нижней "юбки корабля" модифицированной летающей тарелки
	void Back(HPEN Pen);                             // отрисовка выпуклости посередине модифицированной летающей тарелки
	void Windows(HPEN Pen, HBRUSH Brush);            // отрисовка окон внутри тела модифицированной летающей тарелки
	void Show();                                     // показать модифицированную летающую тарелку на экране. Виртуальный метод
	void Hide();                                     // скрыть модифицированную летающую тарелку с экрана. Виртуальный метод

	int Left_Border();                               // вернуть значение самой левой точки модифицированной летающей тарелки
	int Right_Border();                              // вернуть значение самой правой точки модифицированной летающей тарелки
	int Low_Border();                                // вернуть значение самой низкой точки модифицированной летающей тарелки
	int High_Border();                               // вернуть значение самой левой точки модифицированной летающей тарелки
};// Modify_FlyingPlate




/*-----------------------------------------------------------------------------------------------------------------------*/
/*             Корабли          */
/*------------------------------*/

/*------------------------------------------------------------------------*/
/*               Interface                */
/*----------------------------------------*/

// общие действия. Разная реализация. В одних случаях методы нужны, а в других - нет
// фунции интерфейса должны быть принудительно реализованы
class IShip
{
	virtual void engines(HPEN Pen, HBRUSH Brush) = 0;   // отрисовка двигателей
	virtual void body(HPEN Pen, HBRUSH Brush) = 0;      // отрисовка корпуса корабля
	virtual void cabin(HPEN Pen, HBRUSH Brush) = 0;     // отрисовка кабины корабля
};// IShip


/*------------------------------------------------------------------------*/
/*              Ship                */
/*----------------------------------*/

// производный класс Корабль от Point и по определению от Location. Производный от интерфейса IShip
class Ship : public Point, public IShip
{
protected:
	double m_scale;                       // размер. Параметр для отрисовки объекта
	int s_number;                         // номер. Параметр для матрицы переходов кораблей
public:
	Ship(double InitX, double InitY);     // конструктор
	~Ship();                              // деструктор
	double GetScale() const;              // геттер для получения значения размера
	void SetScale(double NewScale);       // сеттер для принудительной установки значения размера
	int GetSNumber() const;               // константный геттер для получения значения номера корабля
	void SetSNumber(int NewSNumber);      // сеттер для принудительной установки значения значения номера корабля
	void engines(HPEN Pen, HBRUSH Brush); // отрисовка двигателей
	void body(HPEN Pen, HBRUSH Brush);    // отрисовка корпуса корабля
	void cabin(HPEN Pen, HBRUSH Brush);   // отрисовка кабины корабля

	// виртуальные функции
	void Show();                          // показать корабль на экране. Виртуальный метод
	void Hide();                          // скрыть корабль с экрана. Виртуальный метод

	virtual double Left_Border();         // вернуть самую левую точку фигуры корабля/ сломанного корабля
	virtual double Right_Border();        // вернуть самую правую точку фигуры корабля/ сломанного корабля
	virtual double High_Border();         // вернуть самую верхнюю точку фигуры корабля/ сломанного корабля
	virtual double Low_Border();          // вернуть самую нижнюю точку фигуры корабля/ сломанного корабля
};// Ship


/*------------------------------------------------------------------------*/
/*              Broke_Ship                */
/*----------------------------------------*/

// производный класс Сломанный Корабль от  Ship и по определению от Point и Location. Производный от интерфейса IShip
class Broke_Ship : public Ship
{
protected:
	// размер. Параметр для отрисовки объекта. Меняется в конструкторе
	// Номер. Параметр для матрицы переходов кораблей. Меняется в конструкторе
public:
	Broke_Ship(double InitX, double InitY);      // конструктор.
	~Broke_Ship();                               // деструктор
	void engines(HPEN Pen, HBRUSH Brush);        // отрисовка одного двигателя
	void Show();                                 // показать сломанный корабль на экране. Виртуальный метод
	void Hide();                                 // скрыть сломанный корабль с экрана. Виртуальный метод
};// Broke_Ship


/*------------------------------------------------------------------------*/
/*             Infinity_Ship              */
/*----------------------------------------*/

// производный класс Бесконечный Корабль от  Ship и по определению от Point и Location. Производный от интерфейса IShip
class Infinity_Ship : public Ship
{
protected:
	// Размер. Параметр для отрисовки объекта. Меняется в конструкторе
	// Номер. Параметр для матрицы переходов кораблей. Меняется в конструкторе
public:
	Infinity_Ship(double InitX, double InitY);   // конструктор
	~Infinity_Ship();                            // деструктор
	void engines(HPEN Pen, HBRUSH Brush);        // отрисовка двигателей
	void body(HPEN Pen, HBRUSH Brush);           // отрисовка корпуса корабля
	void cabin(HPEN Pen, HBRUSH Brush);          // отрисовка кабины корабля

	// вирутальные функции
	void Show();                                 // показать бесконечный корабль на экране. Виртуальный метод
	void Hide();                                 // скрыть бесконечный корабль с экрана. Виртуальный метод

	double Left_Border();         // вернуть самую левую точку фигуры бесконечного корабля
	double Right_Border();        // вернуть самую правую точку фигуры бесконечного корабля
	double High_Border();         // вернуть самую верхнюю точку фигуры бесконечного корабля
	double Low_Border();          // вернуть самую нижнюю точку фигуры бесконечного корабля
};// Infinity_Ship




/*------------------------------------------------------------------------------------------------------*/
/*              Пули            */
/*------------------------------*/

/*------------------------------------------------------------------------*/
/*        Абстрактный базовый класс       */
/*----------------------------------------*/

class ABullet
{
protected:
	int m_caliber;                               // калибр пули
public:
	ABullet(int Initcaliber);                    // конструктор с передачей значения калибра
	virtual ~ABullet();                          // виртуальный деструктор. Без виртуального деструктора, при удалении объектапроизводного класса через указатель на базовый класс, деструктор производного класса не будет вызван
	int GetCaliber() const;                      // геттер для получения значения размера

	// чистая виртуальная функция
	virtual void SetCaliber(int NewCaliber) = 0; // сеттер для принудительной установки значения размера
};// ABullet


/*------------------------------------------------------------------------*/
/*              Обычная пуля           */
/*-------------------------------------*/

// производный класс Пуля от Point и по определению от Location. И ABullet
class Bullet : public Point, public ABullet
{
protected:
	// Калибр пули - параметр для отрисовки
	int m_scale;                                  // нумерация пуль
public:
	Bullet(double InitX, double InitY);           // конструктор
	~Bullet();                                    // деструктор

	int GetScale() const;                         // константный геттер для получения значения номера
	void SetScale(int NewScale);                  // сеттер для принудительной установки значения номера

	// Для принудительной реализации из абстрактного базового класса
	void SetCaliber(int NewCaliber);              // сеттер для принудительной установки значения размера

	// виртуальные функции
	void Show();                                  // показать обычную пулю на экране. Виртуальный метод
	void Hide();                                  // скрыть обычную пулю с экрана. Виртуальный метод
};// Bullet


/*------------------------------------------------------------------------------------------------------*/
/*            Желтая  пуля             */
/*-------------------------------------*/

// производный класс Желтая пуля от обычной пули и по определению от Point и Location. И ABullet
class Yellow_Bullet : public Bullet
{
	// Калибр. Параметр для отрисовки объекта. Меняется в конструкторе
	// Номер. Параметр для матрицы. Меняется в конструкторе
public:
	Yellow_Bullet(double InitX, double InitY);    // конструктор
	~Yellow_Bullet();                             // деструктор

	// виртуальные функции
	void Show();                                  // показать жёлтую пулю на экране. Виртуальный метод
	// переопределения метода Hide() нет. Используется родительская реализация
};// Yellow_Bullet


/*------------------------------------------------------------------------------------------------------*/
/*            Красная  пуля            */
/*-------------------------------------*/

// производный класс Красная пуля от обычной пули и по определению от Point и Location. И ABullet
class Red_Bullet : public Bullet
{
protected:
	int acceleration;                              // ускорение
	// Поле m_caliber используется родительское. Меняется в конструкторе
	// Номер. Параметр для матрицы. Меняется в конструкторе
public:
	Red_Bullet(double InitX, double InitY);        // конструктор
	~Red_Bullet();                                 // деструктор
	int GetAcceleration() const;                   // константный геттер для получения значения ускорения
	void SetAcceleration(int NewAcceleration);     // сеттер для установки значения ускорения

	// виртуальные функции
	void Show();                                   // показать красную пулю на экране. Виртуальный метод
	// переопределения метода Hide() нет. Используется родительская реализация
};// Red_Bullet


/*------------------------------------------------------------------------------------------------------*/
/*            Зелёная  пуля            */
/*-------------------------------------*/

// отличительное свойство - торможение через несколько шагов
// производный класс Зелёная пуля от обычной пули и по определению от Point и Location. И ABullet
class Green_Bullet : public Bullet
{
protected:
	int freeze;                                 // заморозка пули. Пуля летит не до конца консоли, а определённую дистанцию
	// Поле m_caliber используется родительское. Меняется в конструкторе
	// Номер. Параметр для матрицы. Меняется в конструкторе
public:
	Green_Bullet(double InitX, double InitY);   // конструктор
	~Green_Bullet();                            // деструктор
	int GetFreeze() const;                      // константный геттер для текущего значения торможения
	void Setfreeze(int NewFreeze);              // сеттер для принудительной установки текущего значения торможения

	// виртуальные функции
	void Show();                                // показать зелёную пулю на экране. Виртуальный метод
};// Green_Bullet


/*------------------------------------------------------------------------------------------------------*/
/*            Синяя  пуля            */
/*-----------------------------------*/

// Отличается ещё меньшим количеством шагов до исчезновения
// производный класс Синяя пуля от зеленой пули и по определению от обычной пули, Point и Location. И ABullet
class Blue_Bullet : public Green_Bullet
{
	// Поле m_caliber используется прародителя. Меняется в конструкторе
	// Номер. Параметр для матрицы. Меняется в конструкторе
public:
	Blue_Bullet(double InitX, double InitY);   // конструктор
	~Blue_Bullet();                            // деструктор

	// виртуальные функции
	void Show();                               // показать синюю пулю на экране. Виртуальный метод
};// Blue_Bullet




/*------------------------------------------------------------------------------------------------------*/
/*              Бомбы           */
/*------------------------------*/

/*------------------------------------------------------------------------*/
/*        Абстрактный базовый класс       */
/*----------------------------------------*/

class ABomb
{
protected:
	double m_radius;                               // радиус бомбы
	int extra_speed;                               // ускорение
public:
	ABomb(double InitRadius, int InitExtraSpeed);  // конструктор с передачей значения радиуса и ускорения
	~ABomb();                                      // деструктор
	double GetRadius() const;                      // константный геттер для получения значения радиуса
	int GetExtra_speed() const;                    // константный геттер для получения значения ускорения
	void SetExtra_speed(int NewSpeed);             // сеттер для принудительной установки значения ускорения
	virtual void SetRadius(double NewRadius) = 0;  // сеттер для принудительной установки значения радиуса

};// ABomb


/*------------------------------------------------------------------------*/
/*              Обычная бомба          */
/*-------------------------------------*/

// производный класс БОМБА от Point и по определению от Location. И ABomb
class Bomb : public Point, public ABomb
{
protected: 
	// радиус бомбы - параметр для отрисовки
	// ускорение - параметр для движения бомбы
	int m_numb;                                    // нумерация бомб
public:
	// конструктор с передачей значения номера, радиуса, ускорения по умолчанию
	Bomb(int InitX, int InitY, int InitNumb = 0, int InitRadius = 9, int ExtraSpeed = 0);
	~Bomb();                                       // деструктор
	void SetRadius(double NewRadius);              // сеттер для принудительной установки значения радиуса
	int GetNumb() const;                           // константный геттер для получения значения номера
	void SetNumb(int NewNumb);                     // сеттер для принудительной установки значения номера
	
	// виртуальные функции 
	void Show();                                   // показать обычную бомбу на экране. Виртуальный метод
	void Hide();                                   // скрыть обычную бомбу с экрана. Виртуальный метод
};// Bomb


/*------------------------------------------------------------------------------------------------------*/
/*            Красная  бомба           */
/*-------------------------------------*/

// производный класс Красная бомба от обычной бомбы и по определению от Point и Location. И ABomb 
// Отличие от других: наличие ускорения
class Red_Bomb : public Bomb
{
	// радиус бомбы - параметр для отрисовки
    // ускорение - параметр для движения бомбы
	// нумерация бомб берётся поле родителя

public:
	// конструктор с передачей значения номера, радиуса по умолчанию. Ускорение устанавливается в конструкторе
	Red_Bomb(int InitX, int InitY, int InitNumb = 1, int InitRadius = 9);
	~Red_Bomb();                                   // деструктор
	
	// виртуальные функции
	void Show();                                   // показать красную бомбу на экране. Виртуальный метод
	// скрыть Красную бомбу с экрана. Метод берётся у родителя, т.к. параметры радиуса одинаковые
};// Red_Bullet


/*------------------------------------------------------------------------------------------------------*/
/*          Фиолетовая  бомба          */
/*-------------------------------------*/

// производный класс Фиолетовая бомба от обычной бомбы и по определению от Point и Location. И ABomb 
class Purple_Bomb : public Bomb
{
	// радиус бомбы - параметр для отрисовки
    // ускорение - параметр для движения бомбы
    // нумерация бомб берётся поле родителя

public:
	// конструктор с передачей значения номера,радиуса по умолчанию. Ускорение устанавливается в конструкторе
	Purple_Bomb(int InitX, int InitY, int InitNumb = 2, int InitRadius = 12);
	~Purple_Bomb();                                // деструктор
	
	// виртуальные функции
	void Show();                                   // показать фиолетовую бомбу на экране. Виртуальный метод
	void Hide();                                   // скрыть фиолетовую бомбу с экрана. Виртуальный метод
};// Purple_Bomb


/*------------------------------------------------------------------------------------------------------*/
/*            Зелёная  бомба           */
/*-------------------------------------*/

// производный класс Зеленая бомба от обычной бомбы и по определению от Point и Location. И ABomb 
class Green_Bomb : public Bomb
{
protected:
	// радиус бомбы - параметр для отрисовки
    // ускорение - параметр для движения бомбы
    // нумерация бомб берётся поле родителя
	int step;                                      // заморозка Зелёной бомбы. Бомба летит не до конца консоли, а определённую дистанцию
	
public:
	// конструктор с передачей значения номера, радиуса по умолчанию. Ускорение и начальное значение шагов до заморозки устанавливается в конструкторе
	Green_Bomb(int InitX, int InitY, int InitNumb = 3, int InitRadius = 9);
	~Green_Bomb();                                 // деструктор
	int GetStep() const;                           // константный геттер для текущего значения торможения
	void SetStep(int NewStep);                     // сеттер для принудительной установки текущего значения торможения
	
	// виртуальные функции
	void Show();                                   // показать зелёную бомбу на экране. Виртуальный метод
	// скрыть Зеленую бомбу с экрана. Метод берётся у родителя, т.к. параметры радиуса одинаковые
};// Green_Bomb